package file;


import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import net.contentobjects.jnotify.JNotify;
import net.contentobjects.jnotify.JNotifyListener;
import net.contentobjects.jnotify.JNotifyException;



public class JNotifyLinuxRemote implements  JNotifyListener {
	private static final String BASE_BAK_PATH =ConfigMapUtil.getValueByKey("base.bakpath");
	private static final String TARGET_BASE_PATH =ConfigMapUtil.getValueByKey("target.base.path");
	private static final String REMOTE_IP =ConfigMapUtil.getValueByKey("remote.ip");
	private static final String REMOTE_PWD =ConfigMapUtil.getValueByKey("remote.pwd");
	private static final String REMOTE_USER =ConfigMapUtil.getValueByKey("remote.user");
	private static final String REMOTE_PORT =ConfigMapUtil.getValueByKey("remote.port");
	//public static String sourceFtpFileName="";
	//public static String sourceFtpFileName2="";
	/** 被监视的目录 */
	String path = BASE_BAK_PATH;
	/** 关注目录的事件 */
	int mask = JNotify.FILE_CREATED| JNotify.FILE_DELETED| JNotify.FILE_MODIFIED | JNotify.FILE_RENAMED;
 ;
	/** 是否监视子目录，即级联监视 */
	boolean watchSubtree = true;
	/** 监听程序Id */
	public int watchID;
	
	static{
        List<File> list = getFileSort(BASE_BAK_PATH);
        for (File file : list) {
        	startFirstRemote(file.getParent(),file.getPath());
        	
        }
	 }

 
	public static void main(String[] args) {
		new JNotifyLinuxRemote().beginWatch();
	}
 
	/**
	 * 容器启动时启动监视程序
	 * 
	 * @return
	 */
	public void beginWatch() {
		/** 添加到监视队列中 */
		try {
			this.watchID = JNotify.addWatch(BASE_BAK_PATH, mask, watchSubtree, (JNotifyListener) this);
			System.err.println("jnotify -----------启动成功-----------");
		} catch (JNotifyException e) {
			e.printStackTrace();
		}
		// 死循环，线程一直执行，休眠一分钟后继续执行，主要是为了让主线程一直执行
		// 休眠时间和监测文件发生的效率无关（就是说不是监视目录文件改变一分钟后才监测到，监测几乎是实时的，调用本地系统库）
		while (true) {
			try {
				Thread.sleep(60000);
			} catch (InterruptedException e) {// ignore it
			}
		}
	}
	
	public static String subpath3(String str){
		if(str.split("/").length>1){
			//这里是获取"\\"符号的位置 
	        Matcher slashMatcher = Pattern.compile("/").matcher(str);
	        int mIdx = 0;
			while(slashMatcher.find()) {
			    mIdx++;
			    //当"\\"符号第三次出现的位置  
			    if(mIdx == 2){
			        break;
			    }
			}
	        return str.substring(slashMatcher.start());
		}
		return str;
	}
	
	public static boolean checkFileWritingOn(File file) throws Exception{
	    long oldLen = 0;
	    long newLen = 0;
	    while(true){
	      newLen = file.length();
	      if ((newLen - oldLen) > 0||newLen==0) {
	        oldLen = newLen;
	        //System.out.println(file.length());
	        System.err.println(file.getName() + " being transferred");
	        Thread.sleep(2000);
	      } else {
	        //System.out.println("done");
	    	 System.err.println(file.getName() + " transmit complete");
	        return true;
	      }
	    }
}
    
	public static void startFirstRemote(String parentPath,String path ){  
		String sourceFile=BASE_BAK_PATH+path.substring(BASE_BAK_PATH.length());
		String remoteFile=TARGET_BASE_PATH+path.substring(BASE_BAK_PATH.length());
        String tagteChildPath=TARGET_BASE_PATH+parentPath.substring(BASE_BAK_PATH.length());;
        String mkdir="sshpass -p "+REMOTE_PWD+" ssh "+"-p "+REMOTE_PORT+" "+REMOTE_USER+"@"+REMOTE_IP+" [ -d "+tagteChildPath+" ]"
        		+" || mkdir -p "+tagteChildPath;
		StringBuffer buf=new StringBuffer();
        buf.append("sshpass -p ").append(REMOTE_PWD).append(" ").append("scp ").append("-P ").append(REMOTE_PORT).append(" ")
        .append(sourceFile).append(" ").append(REMOTE_USER).append("@").append(REMOTE_IP)
        .append(":").append(remoteFile);
		String del="rm -rf "+sourceFile;
        try {
			ConfigMapUtil.runShell(mkdir);
			System.err.println("程序启动时：创建远程子文件夹命令-----"+mkdir);
		} catch (IOException e2) {
			e2.printStackTrace();
		}
    	try {
            File file = new File(sourceFile);
            boolean isfinsh=checkFileWritingOn(file);
            if(isfinsh==true) {
            ConfigMapUtil.runShell(buf.toString());
            System.err.println("程序启动时：拷贝至远程目录命令-----"+buf.toString());
            ConfigMapUtil.runShell(del);
            System.err.println("程序启动时：删除bak目录文件命令-----"+del);
            }
        } catch (Exception e) {
        	System.err.println(e.getMessage());
        }
	}
	
	public static void copyRemote(String fileName){  
		String sourceFile=BASE_BAK_PATH+"/"+fileName;
		String remoteFile=TARGET_BASE_PATH+"/"+fileName;
        String childPath=lastsub(fileName);
        String tagteChildPath=TARGET_BASE_PATH+"/"+childPath;
        String mkdir="sshpass -p "+REMOTE_PWD+" ssh "+"-p "+REMOTE_PORT+" "+REMOTE_USER+"@"+REMOTE_IP+" [ -d "+tagteChildPath+" ]"
        		+" || mkdir -p "+tagteChildPath;
		StringBuffer buf=new StringBuffer();
        buf.append("sshpass -p ").append(REMOTE_PWD).append(" ").append("scp ").append("-P ").append(REMOTE_PORT).append(" ")
        .append(sourceFile).append(" ").append(REMOTE_USER).append("@").append(REMOTE_IP)
        .append(":").append(remoteFile);
		String del="rm -rf "+sourceFile;
        try {
			ConfigMapUtil.runShell(mkdir);
			System.err.println("创建远程子文件夹命令-----"+mkdir);
		} catch (IOException e2) {
			e2.printStackTrace();
		}
    	try {
            File file = new File(sourceFile);
			boolean isfinsh=checkFileWritingOn(file);
			if(isfinsh==true) {
            ConfigMapUtil.runShell(buf.toString());
            System.err.println("拷贝至远程目录命令-----"+buf.toString());
            ConfigMapUtil.runShell(del);
            System.err.println("删除bak目录命令-----"+del);
			}
        } catch (Exception e) {
        	System.err.println(e.getMessage());
        }
	}
	
    public static String lastsub(String str) {
    	int i=str.lastIndexOf("/");
    	return str.substring(0, i);
    }

	 
   public static List<File> getFileSort(String path) {
   	 
       List<File> list = getFiles(path, new ArrayList<File>());

       if (list != null && list.size() > 0) {

           Collections.sort(list, new Comparator<File>() {
               public int compare(File file, File newFile) {
                   if (file.lastModified() < newFile.lastModified()) {
                       return 1;
                   } else if (file.lastModified() == newFile.lastModified()) {
                       return 0;
                   } else {
                       return -1;
                   }

               }
           });

       }

       return list;
   }



   public static List<File> getFiles(String realpath, List<File> files) {

       File realFile = new File(realpath);
       if (realFile.isDirectory()) {
           File[] subfiles = realFile.listFiles();
           for (File file : subfiles) {
               if (file.isDirectory()) {
                   getFiles(file.getAbsolutePath(), files);
               } else {
                   files.add(file);
               }
           }
       }
       return files;

   }
   
   

   
 
	/**
	 * 当监听目录下一旦有新的文件被创建，则即触发该事件
	 * 
	 * @param wd
	 *            监听线程id
	 * @param rootPath
	 *            监听目录
	 * @param name
	 *            文件名称
	 */
	@Override
	public void fileCreated(int wd, String rootPath, String Filename) {
		System.err.println("fileCreated--rootPath " + rootPath);
		System.err.println("fileCreated--name "  + Filename);
		File file=new File(rootPath+"/"+Filename);
		if(file.isDirectory()) {
			return ;
		}
		copyRemote(Filename);
		
		

	}

	@Override
	public void fileDeleted(int arg0, String arg1, String arg2) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void fileModified(int arg0, String rootPath, String name) {
		// TODO Auto-generated method stub

		
		//System.err.println("fileModified, the modified file path is " + rootPath + "/" + name);
        
		//copyfile(sourceFile, tagetFile);
		//renamePic(name,sourePath);
		//System.out.println("源文件路径："+sourceFile);
		//System.err.println("文件被创建, 创建位置为： " +name);
	}

	@Override
	public void fileRenamed(int arg0, String arg1, String arg2, String arg3) {
		// TODO Auto-generated method stub
		
	}
	
	



}
